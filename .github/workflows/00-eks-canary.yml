name: EKS-Canary

on:
  push:
# https://docs.github.com/en/free-pro-team@latest/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event
  workflow_dispatch:
    # inputs:
    #   subsys:
    #     type: string
    #     default: inputValue
    #   sigla:
    #     type: string
    #     default: SC4
    #   jobsuccess:
    #     type: string
    #     default: sucesso
    #   jobfailed:
    #     type: string
    #     default: falha
#   repository_dispatch:
#     types: [on-demand-test]

env:
  MY_WORKFLOW_VARIABLE: "My workflow var value"
  SIGLA: ""

jobs:
  eks-onebox-gradual-deployment:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      actions: read
    steps:
      - uses: azure/setup-kubectl@v3
        # with:
        #   version: '<version>' # default is latest stable
        id: install

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-2

      - name: Update kube config
        run: aws eks update-kubeconfig --name cell-1 --region us-east-2

      - name: List pods
        run: |
          kubectl get pods

      - name: Query AWS CloudWatch Alarm State
        id: check_alarm
        run: |
          ALARM_STATE=$(aws cloudwatch describe-alarms --alarm-names "cell-1-onebox-cpu-utilization-anomaly-detection" --query "MetricAlarms[0].StateValue" --output text)
          echo "Alarm state: $ALARM_STATE"
          if [ "$ALARM_STATE" = "ALARM" ]; then
            echo "::set-output name=alarm_triggered::true"
          fi

      - name: Handle ALARM state
        if: steps.check_alarm.outputs.alarm_triggered == 'true'
        run: |
          echo "Alarm state is ALARM. Handling error..."
          # Here you can add specific actions, such as sending notifications, triggering other workflows, or rolling back deployments
          exit 1

      - name: Checkout code
        uses: actions/checkout@v4.1.3
        with:
          # repository: sudopablosilva/argo
          ref: develop

      - name: Set up Python
        uses: actions/setup-python@v5.1.0

      - name: Install Python dependencies
        run: python -m pip install pyyaml

      - name: Deploy to Clusters
        env:
          SERVICE_NAME: openfinance
          PATH_TO_MANIFEST: myapp/applicationsets.yaml
        run: |
          import yaml
          import subprocess
          import sys

          def modify_and_print_yaml(cluster, cell_name, service_name, cluster_name, workload_type, template_path):
              with open(template_path, 'r') as file:
                  data = yaml.safe_load(file)

              data['metadata']['name'] = f'{clusterName}-{cellName}-{serviceName}-{workloadType}'
              element = data['spec']['generators'][0]['list']['elements'][0]
              element['cluster'] = cluster
              element['cellName'] = cell_name
              element['serviceName'] = service_name
              element['clusterName'] = cluster_name
              element['workloadType'] = workload_type

              return yaml.safe_dump(data)

          clusters = ["cell-1", "cell-2"]
          types = ["onebox", "normal"]
          for cluster in clusters:
            for type in types:
              yaml_output = modify_and_print_yaml(cluster, cell_name, service_name, cluster_name, workload_type, template_path)
              with open('modified_manifest.yaml', 'w') as f:
                f.write(yaml_output)
              subprocess.run(['kubectl', 'apply', '-f', 'modified_manifest.yaml'])
              print(f"Deployed {type} in {cluster}")
          # Implement your check and wait logic here
        shell: python
    # - uses: azure/k8s-set-context@v3
    #         with:
    #             method: kubeconfig
    #             kubeconfig: <your kubeconfig>
    #             context: <context name> # current-context from kubeconfig is used as default
    
    #       - uses: Azure/k8s-deploy@v4
    #         with:
    #           # resource-group: yourResourceGroup
    #           # name: mynginxfromgithub
    #           action: deploy
    #           strategy: basic
          
    #           private-cluster: true
    #           manifests: |
    #             https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/controllers/nginx-deployment.yaml
    #           images: |
    #             nginx:1.14.3

      # - name: Login to Amazon ECR
      #   id: login-ecr
      #   uses: aws-actions/amazon-ecr-login@v1
    
      # - name: Set up Kubernetes context
      #   env:
      #     KUBECONFIG_CONTENTS: ${{ secrets.MYKUBECONFIG }}
      #   run: |
      #     mkdir -p $HOME/.kube
      #     echo "$KUBECONFIG_CONTENTS" > $HOME/.kube/config
      #     kubectl config set-context --current --namespace=default
      #     kubectl get pods

      # - name: Deploy to Kubernetes
      #   run: |
      #     kubectl apply -f deployment.yaml
          
      # - uses: azure/k8s-actions/k8s-set-context@master
      #   with:
      #     kubeconfig: '${{ secrets.MYKUBECONFIG }}'
      #   id: login

      # - uses: actions-hub/kubectl@master
      #   env:
      #     KUBE_CONFIG: ${{ secrets.MYKUBECONFIG }}

      # - name: Build and push CONTAINER_NAME
      #   uses: ianbelcher/eks-kubectl-action@master
      #   with:
      #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
      #     aws-region: us-east-2
      #     cluster_name: cluster-with-karpenter-2
      #     eks_role_arn: ${{ secrets.EKS_ROLE_ARN }}
      #     kubernetes_version: v1.21.0
      #     args: set image --record deployment/pod-name pod-name=${{ steps.build.outputs.IMAGE_URL }}

      # - uses: azure/k8s-set-context@v3
      #   with:
      #     method: kubeconfig
      #     kubeconfig: ${{ secrets.MYKUBECONFIG }}

      

